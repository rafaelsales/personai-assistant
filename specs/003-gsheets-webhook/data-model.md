# Data Model: Google Sheets Webhook Server

**Feature**: 003-gsheets-webhook
**Date**: 2025-11-01
**Phase**: 1 (Design & Contracts)

## Overview

This feature does not introduce new database entities. It reuses the existing `emails` table schema from `src/database.js` to store webhook payloads from Google Apps Script.

## Existing Schema (Reference)

### Entity: Email

**Source**: Defined in `src/database.js` (lines 156-167)
**Table**: `emails`

#### Fields

| Field | Type | Constraints | Description |
|-------|------|-------------|-------------|
| id | TEXT | PRIMARY KEY, NOT NULL | Gmail message ID (globally unique identifier) |
| thread_id | TEXT | NOT NULL | Gmail thread ID (groups related emails) |
| received_at | TEXT | NOT NULL | ISO 8601 timestamp when email was received in Gmail |
| downloaded_at | TEXT | NOT NULL | ISO 8601 timestamp when email was downloaded to database |
| from_address | TEXT | NOT NULL | Sender email address |
| to_address | TEXT | NOT NULL | Recipient email addresses (comma-separated if multiple) |
| cc_address | TEXT | NULL | CC recipient addresses (comma-separated if multiple) |
| subject | TEXT | NOT NULL | Email subject line |
| labels | TEXT | NOT NULL | Gmail labels (comma-separated) |
| body | TEXT | NOT NULL | Email body content (plain text or HTML-stripped) |

#### Indexes

- **Primary Key**: `id` (ensures uniqueness, enables idempotent inserts)
- **idx_downloaded_at**: On `downloaded_at` (for chronological queries)
- **idx_from_address**: On `from_address` (for sender-based queries)
- **idx_thread_id**: On `thread_id` (for conversation threading)

#### Validation Rules

Enforced by webhook server before calling `storeEmail()`:

1. **Required Fields**: id, thread_id, received_at, downloaded_at, from_address, to_address, subject, labels, body must be present
2. **Type Validation**: All fields must be strings (TEXT type)
3. **Non-Empty**: Required fields must not be empty strings (except labels which can be empty if no labels)
4. **Length Constraints**:
   - id: Gmail message IDs are typically 16-20 characters
   - body: Up to 1MB (enforced by webhook request size limit), stored as-is
   - Other fields: No explicit length limits, but reasonable email header sizes expected

#### State Transitions

N/A - Emails are immutable once stored. No state transitions.

## Webhook Request Payload

### Entity: WebhookEmailPayload

**Source**: Generated by `gmail-to-sheet.gs` (lines 163-175)
**Format**: JSON

#### Structure

```json
{
  "id": "string (Gmail message ID)",
  "thread_id": "string (Gmail thread ID)",
  "received_at": "string (ISO 8601 timestamp)",
  "downloaded_at": "string (ISO 8601 timestamp)",
  "broadcasted_at": "string (ISO 8601 timestamp) | empty string",
  "from_address": "string (email address)",
  "to_address": "string (comma-separated email addresses)",
  "cc_address": "string (comma-separated email addresses) | empty string",
  "subject": "string (email subject)",
  "labels": "string (comma-separated Gmail labels)",
  "body": "string (email body text, max 50k chars from Sheets)"
}
```

#### Example

```json
{
  "id": "18f3a8b9c7d2e1f0",
  "thread_id": "18f3a8b9c7d2e1f0",
  "received_at": "2025-11-01 10:30:00",
  "downloaded_at": "2025-11-01 10:31:15",
  "broadcasted_at": "2025-11-01 10:31:20",
  "from_address": "sender@example.com",
  "to_address": "recipient@example.com",
  "cc_address": "cc@example.com, cc2@example.com",
  "subject": "Important Meeting Tomorrow",
  "labels": "INBOX, IMPORTANT, UNREAD",
  "body": "Hi there,\n\nJust a reminder about our meeting tomorrow at 2pm.\n\nBest regards,\nSender"
}
```

#### Field Mapping to Database Schema

Direct 1:1 mapping - no transformation needed:

| Webhook Payload Field | Database Column | Transformation |
|-----------------------|-----------------|----------------|
| id | id | None (pass-through) |
| thread_id | thread_id | None (pass-through) |
| received_at | received_at | None (pass-through) |
| downloaded_at | downloaded_at | None (pass-through) |
| from_address | from_address | None (pass-through) |
| to_address | to_address | None (pass-through) |
| cc_address | cc_address | None (pass-through, may be empty) |
| subject | subject | None (pass-through) |
| labels | labels | None (pass-through) |
| body | body | None (pass-through) |
| broadcasted_at | N/A | Ignored (not stored in database) |

**Note**: The `broadcasted_at` field from Google Sheets is not stored in the database as it's metadata about the Apps Script broadcast operation, not email metadata.

## Validation Schema

### Required Fields Validation

```javascript
const REQUIRED_FIELDS = [
  'id',
  'thread_id',
  'received_at',
  'downloaded_at',
  'from_address',
  'to_address',
  'subject',
  'labels',
  'body'
];

function validatePayload(payload) {
  const missingFields = REQUIRED_FIELDS.filter(field => {
    return !payload.hasOwnProperty(field) ||
           payload[field] === null ||
           payload[field] === undefined ||
           (typeof payload[field] === 'string' && payload[field].trim() === '');
  });

  if (missingFields.length > 0) {
    return {
      valid: false,
      error: `Missing required fields: ${missingFields.join(', ')}`
    };
  }

  return { valid: true };
}
```

### Type Validation

```javascript
function validateTypes(payload) {
  // All fields must be strings
  for (const field of REQUIRED_FIELDS) {
    if (typeof payload[field] !== 'string') {
      return {
        valid: false,
        error: `Field '${field}' must be a string, got ${typeof payload[field]}`
      };
    }
  }

  // Optional fields (if present) must also be strings
  if (payload.cc_address !== undefined && typeof payload.cc_address !== 'string') {
    return {
      valid: false,
      error: `Field 'cc_address' must be a string, got ${typeof payload.cc_address}`
    };
  }

  return { valid: true };
}
```

## Idempotency Model

### Duplicate Detection

**Mechanism**: Primary key constraint on `id` field

**Behavior**:
1. Webhook server calls `storeEmail(db, payload)`
2. `storeEmail()` checks: `SELECT 1 FROM emails WHERE id = ?`
3. If exists: return `false` (duplicate detected)
4. If not exists: INSERT and return `true` (new email stored)

**Webhook Server Response**:
- Duplicate (`false`): HTTP 200 OK with `{ "status": "success", "action": "skipped", "id": "..." }`
- New email (`true`): HTTP 200 OK with `{ "status": "success", "action": "stored", "id": "..." }`

### Concurrent Request Handling

**Scenario**: Same email ID sent in multiple concurrent webhook requests

**Database Behavior** (with WAL mode):
1. First request: SELECT returns no match, proceeds to INSERT
2. Second request (concurrent): SELECT returns no match, attempts INSERT
3. One INSERT succeeds (becomes writer)
4. Other INSERT fails with PRIMARY KEY constraint violation
5. better-sqlite3 throws error: `SQLITE_CONSTRAINT: UNIQUE constraint failed: emails.id`

**Error Handling**:
```javascript
try {
  const wasStored = storeEmail(db, payload);
  if (wasStored) {
    return { status: 'success', action: 'stored', id: payload.id };
  } else {
    return { status: 'success', action: 'skipped', id: payload.id };
  }
} catch (error) {
  if (error.message.includes('UNIQUE constraint failed')) {
    // Race condition - treat as duplicate
    return { status: 'success', action: 'skipped', id: payload.id };
  }
  // Other database errors
  throw error;
}
```

## Relationships

### Email â†’ Thread Relationship

**Type**: Many-to-One (many emails can belong to one thread)

**Access Pattern**:
- **Query emails in a thread**: `SELECT * FROM emails WHERE thread_id = ? ORDER BY received_at`
- **Available via**: `getEmailsByThread(db, threadId)` from `src/database.js` (lines 245-256)

**Use Case**: Reconstruct email conversation threads for display or processing

### No Relationships with Other Entities

This feature operates independently:
- No user accounts (no authentication)
- No email processing rules (just storage)
- No outbound integrations (receive-only webhook)

## Performance Characteristics

### Write Performance

**Expected Volume**: Low to moderate (Gmail webhook triggers)
- Typical: 1-10 emails/minute
- Burst: 50-100 emails/minute during sync catch-up

**Database Write Latency**:
- SELECT for duplicate check: <1ms (indexed on PRIMARY KEY)
- INSERT operation: 1-5ms (single row, no triggers)
- Total database operation: <10ms

**Bottleneck Analysis**:
- SQLite write lock: Single writer with WAL mode
- Network I/O: Minimal (localhost database)
- JSON parsing: <1ms for typical payloads (<100KB)

### Query Performance

Not applicable - this feature only writes to database. Reads handled by other components.

## Data Retention

**Policy**: Not defined in this feature scope

**Current Behavior**: Emails stored indefinitely

**Future Considerations**:
- Implement retention policy based on `downloaded_at` timestamp
- Archive old emails to separate storage
- Purge emails older than N days

Out of scope for this feature.

## Summary

**Data Model Complexity**: Minimal

- **Entities**: 0 new (reuses existing `emails` table)
- **Validation**: Simple field presence and type checking
- **Relationships**: Existing thread_id relationship (not modified)
- **State**: Immutable (no updates or deletes)
- **Idempotency**: Handled by database PRIMARY KEY constraint

**Integration Points**:
- **Input**: JSON payload from Google Apps Script webhook
- **Output**: SQLite database insert via `storeEmail(db, payload)`
- **Transform**: None (direct field mapping)

This design maximizes simplicity by reusing existing database schema and operations without introducing new entities or complex transformations.
